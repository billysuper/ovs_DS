# DT 演算法視覺化流程圖

**創建日期**: 2025-10-17  
**目的**: 用圖形化方式展示 DT 的運作流程

---

## 📊 核心概念圖

### Decision Tree 結構

```
                    Decision Tree
                         │
           ┌─────────────┴─────────────┐
           │                           │
      Internal Nodes              Leaf Nodes
      (做決策的節點)               (存規則的節點)
           │                           │
    ┌──────┴──────┐              ┌────┴────┐
    │             │              │         │
  測試欄位     分支選擇          規則列表  優先級排序
 (src_ip)    (左/右)           (Rule1)   (高→低)
                               (Rule2)
```

---

## 🌳 樹結構範例

### 簡單三層樹

```
                    [Root]
                 Test: src_ip
            ┌────────┴────────┐
            │                 │
       != 10.0.0.1       == 10.0.0.1
            │                 │
            ▼                 ▼
      [Internal Node]      [Leaf 2]
       Test: dst_port    ┌──────────┐
      ┌─────┴─────┐      │ Rule C   │ p=100
      │           │      │ (catchall)│ p=50
   != 80       == 80     └──────────┘
      │           │
      ▼           ▼
   [Leaf 1]    [Leaf 3]
  ┌────────┐  ┌────────┐
  │ Rule A │  │ Rule B │
  │ p=90   │  │ p=100  │
  └────────┘  └────────┘

規則說明:
  Rule A: dst_port != 80,  priority=90
  Rule B: dst_port == 80,  priority=100
  Rule C: src_ip == 10.0.0.1, priority=100
  Rule C: (catchall), priority=50
```

### 查找流程示例

```
查找: src_ip=10.0.0.1, dst_port=80

Step 1: [Root]
        │
        ├─ 測試: src_ip == 10.0.0.1?
        └─ 結果: YES → 走右邊

Step 2: [Leaf 2]
        │
        ├─ 規則列表:
        │   • Rule C (p=100) ✓ 匹配
        │   • Catchall (p=50)
        └─ 返回: Rule C

結果: 找到 Rule C (priority=100) ✅
```

---

## 🔄 插入演算法流程

### 完整插入流程

```
                開始插入
                   │
                   ▼
            ┌──────────────┐
            │ 樹是空的嗎？ │
            └──┬────────┬──┘
               │ Yes    │ No
               ▼        ▼
          ┌────────┐  ┌──────────────┐
          │ 創建根 │  │ 從根開始遍歷 │
          │ 葉節點 │  └──────┬───────┘
          └────┬───┘         │
               │             ▼
               │      ┌──────────────┐
               │      │ 記錄遍歷路徑 │
               │      └──────┬───────┘
               │             │
               │             ▼
               │      ┌──────────────────┐
               │      │ 當前節點是內部？ │
               │      └──┬────────────┬──┘
               │         │ Yes        │ No
               │         ▼            │
               │  ┌──────────────┐   │
               │  │ 測試欄位值   │   │
               │  │ 選擇左/右    │   │
               │  │ 繼續往下走   │   │
               │  └──────┬───────┘   │
               │         │            │
               │         └────────┐   │
               │                  ▼   ▼
               │             ┌────────────┐
               │             │ 到達葉節點 │
               │             └─────┬──────┘
               │                   │
               │                   ▼
               │             ┌────────────────┐
               │             │ 複製葉節點     │
               │             │ (Copy-on-Write)│
               │             └─────┬──────────┘
               │                   │
               │                   ▼
               │        ┌──────────────────────┐
               │        │ 按優先級插入新規則   │
               │        └──────┬───────────────┘
               │               │
               │               ▼
               │        ┌──────────────────────┐
               │        │ 路徑重建 (COW)       │
               │        │ 從葉到根逐層複製     │
               │        └──────┬───────────────┘
               │               │
               └───────────────┘
                               │
                               ▼
                      ┌─────────────────┐
                      │ 原子更新根指針  │
                      └────────┬────────┘
                               │
                               ▼
                            完成 ✅
```

### Copy-on-Write 詳細過程

```
原始樹:
  [A]────┐
   │     │
  [B]   [C]
   │
  [D]

插入新規則到 D:

Step 1: 遍歷並記錄路徑
  Path: [A, B, D]
  Directions: [left, left]

Step 2: 複製葉節點 D
  [D'] ← 添加新規則

Step 3: 複製父節點 B，指向 D'
  [B']────D'
     │
    [E]  (E 未修改，共享)

Step 4: 複製根節點 A，指向 B'
  [A']───┐
    │    │
   [B']  [C]  (C 未修改，共享)
    │
   [D']

Step 5: 原子切換根指針
  root: [A] → [A']

最終:
  新樹使用: [A', B', D']
  舊樹使用: [A, B, D]
  共享節點: [C, E]
```

### 內存狀態變化

```
時間 T1 (插入前):
┌─────────────┐
│ Root → [A]  │  舊樹
│   ├── [B]   │
│   │   └[D]  │  ← 要插入到這
│   └── [C]   │
└─────────────┘

時間 T2 (COW 複製中):
┌─────────────┐     ┌─────────────┐
│ Root → [A]  │     │ [A'] (new)  │  新樹正在構建
│   ├── [B]   │     │  ├─ [B']    │
│   │   └[D]  │     │  │  └[D']   │  ← 新規則在這
│   └── [C]───┼─────┼──└─ [C]     │  共享
└─────────────┘     └─────────────┘
      ▲                    ▲
   讀者仍在這        新結構準備好

時間 T3 (原子切換):
┌─────────────┐     ┌─────────────┐
│ Root ─X─[A] │     │ Root → [A'] │  切換完成！
│   ├── [B]   │     │   ├── [B']  │
│   │   └[D]  │     │   │   └[D'] │
│   └── [C]───┼─────┼───└── [C]   │
└─────────────┘     └─────────────┘
    等待回收              現在使用

時間 T4 (舊樹回收):
                    ┌─────────────┐
                    │ Root → [A'] │  只剩新樹
                    │   ├── [B']  │
                    │   │   └[D'] │
                    │   └── [C]   │
                    └─────────────┘
```

---

## 🔍 查找演算法流程

### 基本查找流程

```
                開始查找
            (傳入 flow)
                  │
                  ▼
         ┌────────────────┐
         │ 獲取根節點     │
         └────────┬───────┘
                  │
                  ▼
         ┌────────────────────┐
         │ 當前是內部節點嗎？ │
         └─────┬──────────┬───┘
           Yes │          │ No
               ▼          │
      ┌────────────────┐ │
      │ 從flow提取欄位 │ │
      │ (如: src_ip)   │ │
      └────────┬───────┘ │
               │         │
               ▼         │
      ┌────────────────┐ │
      │ 執行測試       │ │
      │ (EQ/PREFIX)    │ │
      └────┬───────┬───┘ │
           │       │     │
       匹配 │       │不匹配
           │       │     │
        右邊│       │左邊 │
           ▼       ▼     │
      ┌────────────────┐ │
      │ 繼續往下走     │ │
      └────────┬───────┘ │
               │         │
               └─────┐   │
                     │   │
                     ▼   ▼
             ┌────────────────┐
             │ 到達葉節點     │
             └────────┬───────┘
                      │
                      ▼
       ┌──────────────────────────┐
       │ 遍歷葉節點的規則列表     │
       └──────────┬───────────────┘
                  │
                  ▼
       ┌──────────────────────────┐
       │ 找優先級最高的可見規則   │
       └──────────┬───────────────┘
                  │
                  ▼
         ┌────────────────┐
         │ 返回規則       │
         │ (或 NULL)      │
         └────────────────┘
```

### 測試類型詳解

#### 精確測試 (EXACT)

```
測試: src_ip == 10.0.0.1?

         [Node]
      Test: src_ip
     Value: 10.0.0.1
           │
    ┌──────┴──────┐
    │             │
    NO            YES
    │             │
    ▼             ▼
 [Left]        [Right]
(其他IP)      (10.0.0.1)

範例:
  Flow 1: src_ip = 10.0.0.1  → YES → 右邊 ✓
  Flow 2: src_ip = 10.0.0.2  → NO  → 左邊 ✓
  Flow 3: src_ip = 192.168.1.1 → NO → 左邊 ✓
```

#### 前綴測試 (PREFIX)

```
測試: dst_ip in 192.168.0.0/16?

         [Node]
      Test: dst_ip
     Prefix: 192.168.0.0/16
     Mask: 255.255.0.0
           │
    ┌──────┴──────┐
    │             │
    NO            YES
    │             │
    ▼             ▼
 [Left]        [Right]
(其他子網)   (192.168.x.x)

範例:
  Flow 1: dst_ip = 192.168.1.1   → YES → 右邊 ✓
  Flow 2: dst_ip = 192.168.255.255 → YES → 右邊 ✓
  Flow 3: dst_ip = 10.0.0.1      → NO  → 左邊 ✓
  Flow 4: dst_ip = 192.167.1.1   → NO  → 左邊 ✓
```

### 葉節點規則選擇

```
葉節點內容:
┌─────────────────────────────────┐
│ Leaf Node                       │
├─────────────────────────────────┤
│ Rules (按優先級排序):           │
│   ┌──────────────────────────┐  │
│   │ Rule A: priority = 100   │  │ ← 第一個
│   │ visible = true           │  │
│   └──────────────────────────┘  │
│   ┌──────────────────────────┐  │
│   │ Rule B: priority = 90    │  │
│   │ visible = true           │  │
│   └──────────────────────────┘  │
│   ┌──────────────────────────┐  │
│   │ Rule C: priority = 80    │  │
│   │ visible = false          │  │ ← 跳過（不可見）
│   └──────────────────────────┘  │
└─────────────────────────────────┘

選擇邏輯:
  1. 遍歷規則列表（從高優先級到低）
  2. 檢查可見性 (version check)
  3. 找到第一個可見的規則
  4. 返回該規則

結果: Rule A (priority=100, visible=true) ✅
```

---

## 📈 性能特性圖

### 查找複雜度對比

```
線性搜尋 (TSS 最壞情況):
Lookups
  │
  │  ╱
  │ ╱
  │╱
  └─────────> Rules (n)
  O(n)

平衡 DT (理想情況):
Lookups
  │    ┌─
  │   ╱
  │  ╱
  │ ╱
  │╱
  └─────────> Rules (n)
  O(log n)

不平衡 DT (當前簡化版):
Lookups
  │
  │  ╱
  │ ╱
  │╱
  └─────────> Rules (n)
  O(n) - 因為所有規則在同一葉節點
```

### 插入開銷

```
COW 複製開銷:
Nodes to copy
  │
  │    ╱
  │   ╱
  │  ╱
  │ ╱
  │╱
  └─────────> Tree depth (d)
  O(d) = O(log n) 對平衡樹

完整複製 vs COW:
  完整複製: 複製所有 n 個節點
  COW:      只複製路徑上的 d 個節點
  
  n = 1000, d = 10
  完整: 1000 次複製
  COW:  10 次複製  ← 100x 改進！
```

---

## 🔄 併發訪問模型

### RCU 保護的讀寫過程

```
時間線:
T0   T1   T2   T3   T4   T5   T6
│    │    │    │    │    │    │
│    │    ▼    │    │    │    │
│    │  寫者   │    │    │    │
│    │  開始   │    │    │    │
│    │         │    │    │    │
│    ▼         │    │    │    │
│  讀者A       │    │    │    │
│  開始        │    │    │    │
│  (看到舊樹)  │    │    │    │
│    │         │    │    │    │
│    │         ▼    │    │    │
│    │       寫者   │    │    │
│    │       創建   │    │    │
│    │       新樹   │    │    │
│    │         │    │    │    │
│    │         │    ▼    │    │
│    │         │  切換   │    │
│    │         │  根指針 │    │
│    │         │  (原子) │    │
│    │         │    │    │    │
│    ▼         │    │    ▼    │
│  讀者A       │    │  讀者B  │
│  完成        │    │  開始   │
│  (仍在舊樹)  │    │  (新樹) │
│    ✅        │    │    │    │
│              │    │    │    │
│              │    │    │    ▼
│              │    │    │  讀者B
│              │    │    │  完成
│              │    │    │    ✅
│              │    │    │
│              │    │    ▼
│              │    │  所有讀者
│              │    │  都離開舊樹
│              │    │
│              │    ▼
│              │  RCU 回收
│              │  舊樹
│              │    ✅
│              ▼
│            寫者完成
│              ✅
```

### 多讀者單寫者模型

```
┌─────────────────────────────────────┐
│          Shared Tree                │
│                                     │
│            [Root]                   │
│           /      \                  │
│         ...      ...                │
└────────┬──────────┬─────────┬──────┘
         │          │         │
    ┌────▼───┐ ┌───▼────┐ ┌──▼─────┐
    │ Reader │ │ Reader │ │ Reader │
    │   A    │ │   B    │ │   C    │
    └────────┘ └────────┘ └────────┘
         │          │         │
         └──────────┴─────────┘
                    │
                 無鎖讀取
                (RCU 保護)

                    │
                    ▼
              ┌──────────┐
              │  Writer  │  ← 創建新樹
              │          │    不阻塞讀者
              └──────────┘
                    │
                    ▼
              原子切換根指針
                    │
                    ▼
              舊樹被回收
           (當所有讀者離開)
```

---

## 🎯 關鍵設計決策圖

### 為什麼用 Decision Tree？

```
問題: 在 N 個規則中找到匹配的規則

方案 1: 線性搜尋
  ┌─────┐  ┌─────┐  ┌─────┐     ┌─────┐
  │ R1  │→ │ R2  │→ │ R3  │ ... │ RN  │
  └─────┘  └─────┘  └─────┘     └─────┘
  逐一比對，最壞 O(N)
  優點: 實現簡單
  缺點: 規則多時很慢

方案 2: Hash Table
  ┌──────┬──────┬──────┬──────┐
  │ [R1] │ [R5] │  []  │ [R3] │
  │ [R2] │      │      │ [R4] │
  └──────┴──────┴──────┴──────┘
  Hash 欄位值，O(1) 查找
  優點: 查找快
  缺點: 不支持前綴/範圍匹配

方案 3: Decision Tree ← 選擇這個
                [Root]
               /      \
            [N1]      [N2]
           /   \      /   \
         [L1] [L2] [L3] [L4]
  逐步縮小範圍，O(log N)
  優點: 支持前綴/範圍，平衡性能
  缺點: 實現較複雜

結論: DT 提供最佳的功能/性能平衡 ✓
```

### 為什麼用 Copy-on-Write？

```
問題: 如何實現無鎖並發？

方案 1: 全局鎖
  Reader ──┐
           ├──► [Lock] ──► [Tree] ◄── [Lock] ◄──┐
  Reader ──┘                                      ├── Writer
  
  缺點: 讀者互相阻塞，寫者阻塞所有人

方案 2: 讀寫鎖
  Readers ────► [RW Lock] ──► [Tree] ◄── [RW Lock] ◄── Writer
  
  優點: 讀者不互相阻塞
  缺點: 寫者仍阻塞讀者

方案 3: Copy-on-Write ← 選擇這個
  Readers ────► [Old Tree]  (無鎖讀取)
                     ▲
                     │ RCU
                     │
  Writer  ────► [New Tree]  (獨立構建)
                     │
                     ▼
              原子切換指針
  
  優點: 
    • 讀者完全無鎖 ✓
    • 寫者不阻塞讀者 ✓
    • 併發性能最佳 ✓
  缺點:
    • 寫者需要複製 (但只複製路徑)

結論: COW + RCU 是併發讀寫的最佳方案 ✓
```

---

## 📚 補充說明

### RCU (Read-Copy-Update) 簡介

```
核心思想: 
  1. 讀者直接讀（無鎖）
  2. 寫者複製並修改
  3. 原子更新指針
  4. 延遲釋放舊版本

┌─────────────────────────────────────┐
│         Read Phase                  │
│  Readers access old version         │
│  No locks needed                    │
└─────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────┐
│         Copy Phase                  │
│  Writer creates new version         │
│  Doesn't affect readers             │
└─────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────┐
│        Update Phase                 │
│  Atomic pointer switch              │
│  New readers see new version        │
└─────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────┐
│         Grace Period                │
│  Wait for old readers to finish     │
│  Then reclaim old version           │
└─────────────────────────────────────┘
```

### Miniflow 和 Minimatch

```
Miniflow: 壓縮的 flow 表示
  struct flow (128+ bytes)
        │
        ▼ 壓縮
  struct miniflow (可變長度)
  只存儲非零的欄位
  
  範例:
    Full flow: [in_port=1, src_ip=10.0.0.1, 其他都是0]
                ↓ 壓縮
    Miniflow:  [in_port=1, src_ip=10.0.0.1]
                (省略零值欄位)

Minimatch: Match + Wildcard 壓縮表示
  用於規則匹配
  節省內存
```

---

**注意**: 這些視覺化圖表展示了理想的運作方式。當前實現有一些簡化（如：插入總是走左邊），但核心概念和結構是一樣的。
